<!DOCTYPE html>
<html lang="en">
<head>
    <title>Oliver Iliffe's Website</title>
    <meta charset="UTF-8">
    <meta name="description" content="DESCRIPTION">
    <meta name="keywords" content="Ruby, Hardware, Programming languages">
    <meta name="author" content="Oliver Iliffe, Dawid Lachowicz">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
        rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
        rel="stylesheet">
    <!-- MATH
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/auto-render.min.js" onload="renderMath()"></script>
    <script>
    const renderMath = () => {
        document.querySelectorAll('.tex-math').forEach(el => {
            renderMathInElement(el, {
                delimiters: [
                    { left: "\\(", right: "\\)", display: false },
                    { left: "\\[", right: "\\]", display: true }
                ]
            });
        });
    };
    </script>  
    ENDMATH -->
    <style>
        :root {
            --almost-black: rgb(30, 30, 30);
            --almost-white: rgb(240, 240, 240);
        }

        :root {
            --primary-color: var(--almost-white);
            --secondary-color: var(--almost-black);
        }

        * {
            box-sizing: border-box;
            color: var(--primary-color);
        }

        .sans-serif {
            font-family: "Open Sans", sans-serif;
        }

        h1,
        h2,
        h3,
        h4 {
            font-family: "Open Sans", sans-serif;
            font-weight: 800;
        }
        
        p {
            font-family: "Open Sans", sans-serif;
        }

        a:hover {
            color: var(--primary-color);
        }

        html {
            margin: 0px;
        }

        body {
            margin: 0px;
            background-color: var(--secondary-color);
            overflow-x: hidden;
        }

        .everything-container {
            padding: 20px;
        }

        @media (max-width: 500px) {
            .everything-container {
                padding: 0px;
            }
        }

        .heading-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0px 20px 0px 20px;
        }

        @media (max-width: 500px) {
            .heading-container {
                margin-bottom: 10px;
            }
        }

        .img-with-border {
            border: 5px solid var(--primary-color);
        }

        .inverse * {
            color: var(--secondary-color);
        }

        .inverse * a:hover {
            color: var(--secondary-color);
        }

        .content-container {
            border-radius: 6px;
            background-color: var(--primary-color);
            padding: 20px 30px 30px 30px;
            position: relative;
        }

        .content-container *>img {
            max-width: 100%;
        }

        @media (max-width: 500px) {
            .content-container {
                border-radius: 0px;
            }
        }

        @media (max-width: 500px) {
            .ferris-the-crab {
                visibility: hidden;
            }
        }

        pre *,
        code *,
        code {
            font-family: "Roboto Mono", monospace;
            font-size: 14px;
            line-height: 20px;
        }

        h1 *,
        h2 *,
        h3 *,
        h4 * {
            font-size: inherit;
        }

        pre {
            overflow-x: auto;
            background-color: var(--almost-black);
            padding: 10px;
            border-radius: 6px;
        }

        pre>code {
            color: rgb(78, 233, 194) !important;
        }

        .tex-math {
            overflow-x: scroll;
        }
    </style>
</head>

<body>
    <div style="max-width: 800px; margin-left: auto; margin-right: auto;">
        <div class="everything-container">
            <div class="heading-container">
                <div style="display: flex; flex-direction: column;">
                    <h1>Oli's Little Guide to Ruby HDL</h1>
                    <span style="position: relative; bottom: 10px; padding-left: 2px;" class="sans-serif">March  2, 2025</span>
                </div>
                <a href="/">
                    <img src="/img/go-back.svg" alt="A navigation arrow to send you back to the site homepage"
                        style="filter: invert(1); height: 30px;" />
                </a>
            </div>
            <div class="content-container inverse">
                <h1>Oli's Little Guide to Ruby</h1><p>This is about the 1986 HDL Ruby, made by <a href="https://www.cse.chalmers.se/~ms/">Mary Sheeran</a>.
It's not quite finished, but I think provides a nice swift introduction
to many of the basic concepts (everything up until registers). If you
are interested in contributing, please do!</p><h2>Basic Relations</h2><ul><li><p> Ruby defines blocks with a domain and range.
</p></li><li><p> Domain variables are read bottom-to-top, left-to-right and are on the
left or top of the block.
</p></li><li><p> Range variables are read left-to-right, bottom-to-top and are on the
bottom or right of the block.
</p></li><li><p> Blocks might perform computation.</p></li></ul><p><img alt="A square labelled lowercase f has an incoming arrow from the left 
  and outgoing arrow to the right." src="image.png"></p><p>In ruby we can describe this as follows:</p><pre lang=""><code>f = VAR a . a $rel a.
</code></pre><p>If <code>f</code> performs a function <code>g</code> on its input, we can write:</p><pre lang=""><code>f = VAR a . a $rel (`g` a).
</code></pre><p><code>f</code> can be used as a function. For example, it is valid to declare a 
new block <code>e == f == g</code>: </p><pre lang=""><code>e = VAR a . a $rel (`f` a).
</code></pre><p>If we have multiple range/domain variables.</p><p><img alt="As before, but now with two incoming/outgoing arrows on both sides of 
  f" src="image-1.png">
  </p><pre lang=""><code>f = VAR a b . &lta, b&gt $rel &lta, b&gt.
</code></pre><p>Or, with computation:</p><pre lang=""><code>f = VAR a b . &lta, b&gt $rel &lt(`inc` a), (`inc` b)&gt.
</code></pre><p>Tuples/lists are defined with angle brackets. </p><p>The left/right sides of <code>$rel</code> can be either inputs or outputs.</p><pre lang=""><code>f = VAR a b . &lt(`inc` a), b&gt $rel &lta, (`inc` b)&gt.
</code></pre><p><img alt="f has a left-incoming wire and a right-outgoing wire, but also two 
  arrows flowing in the other direction, underneath the left-to-right 
  arrows" src="image-2.png"></p><p>With <code>VAR</code> we declare the inputs, in this case <code>a</code> and <code>b</code>.</p><h2>Running things</h2><p>This is dependent on your compiler. You will pass your <code>.rby</code> file into
a compiler and execute it with another program and some inputs. These 
are passed to the <code>current</code> block in your program. For me this looks 
like:</p><pre lang=""><code>rc mycode.rby &amp;&amp; re &quota b&quot
</code></pre><p>You can pass symbols for symbolic execution, or concrete values.</p><h2>One input, lots of input wires</h2><p><code>$wire</code> is a shorthand for <code>$rel</code> without explicit inputs. </p><p>Consider </p><pre lang=""><code>id = a $wire a.
</code></pre><p>Obviously, <code>id 5</code> is just <code>5</code>. But what about <code>id &lt5, 5&gt</code>? 
This is <code>&lt5, 5&gt</code>. Consider a more useful example.</p><pre lang=""><code>fork = a $wire &lta, a&gt.
</code></pre><p><code>fork a</code> is <code>&lta, a&gt</code>, and <code>fork &lta, a&gt</code> is 
<code>&lt&lta, a&gt, &lta, a&gt&gt</code>.</p><h2>Defining Blocks Without <code>$rel</code></h2><p>We can sequence (compose) blocks with <code>;</code>. E.g. <code>f ; g</code>. </p><p><img alt="Two blocks labeled f and g are connected in sequence. g is positioned
to the right of f. An incoming arrow from the left enters f. From the
right of f, an outgoing arrow enters the left-side of g. g has a single
outgoing arrow to the right." src="image-3.png"></p><p>You can do this lots of times with the same block by raising it to the 
power of <code>n</code>. E.g. <code>f^3</code> is <code>f ; f ; f</code>.</p><p>We can define blocks in parallel with <code>[]</code>. E.g. <code>f = [id, inc]</code>.</p><p><img alt="An outer block f with two inputs and two outputs surrounds the inc and
id blocks from which it is composed" src="image-4.png"></p><p>A more complex example might be the following</p><p><img alt="An adder and a multiplier are both supplied the same two inputs
through forked wires. The entire system has two inputs and two outputs,
one representing the output of the multiplier and one the
adder." src="image-5.png"></p><p>The 4-input part after the forking is clearly </p><pre lang=""><code>&lt&lta, b&gt, &lta, b&gt&gt ; [mult, add]
</code></pre><p><code>&lt&lta, b&gt, &lta, b&gt&gt</code> is equivalent to <code>fork &lta, b&gt</code>. Thus the entire 
block is representable as</p><pre lang=""><code>f = fork ; [mult, add].
</code></pre><p>Here's another example </p><pre lang=""><code>add3 = [id, add] ; add.
</code></pre><h2><code>$rel</code> vs block composition</h2><p>Think of $rel as a lambda (anonymous) function, but for relations.</p><p>You can use a lambda everywhere where you can use a named function.</p><pre lang=""><code>f = [VAR x. x $rel x, add].
</code></pre><p>You can also give a lambda a name, just as we have been doing all along, and
then refer to it in other parts of the code.</p><pre lang=""><code>id = VAR x. x $rel x.
f = [id, add].
</code></pre><p>In fact, you can give new names to existing named functions (i.e. function
aliasing):</p><pre lang=""><code>f = [id, add].
g = f.
</code></pre><p>How can we write f using <code>$rel</code> notation? Let's try to draw it, and
use <code>$rel</code> to define the behaviour of the resulting block.</p><p><img alt="Drawing of f being defined in terms of add and id" src="./image-9.svg"></p><p>We can see that <code>f</code> takes 3 inputs, adds the latter two (remember we count from
the bottom up), and produces two outputs. So we can encode that directly as
follows:</p><pre lang=""><code>f = VAR x y z. &ltx, &lty, z&gt&gt $rel &lt(`id` x), (`add` &lty, z&gt)&gt.
</code></pre><p>We can see that <code>;</code> and <code>[]</code> are really just a nice syntactic sugar for
composing blocks, without having to explicitly declare input/output variables.</p><p>We can encode sequential composition with <code>$rel</code> using function application
nesting:</p><pre lang=""><code>fTwice = VAR x. x $rel (`f` (`f` x)).
</code></pre><h2>More Wiring Patterns</h2><p><code>append m n</code> takes a pair of lists of size <code>m</code> and <code>n</code> respectively and
concatenates them into a list of size <code>m+n</code>. E.g.</p><pre lang=""><code>append 2 3 &lt&ltx0,x1&gt,&lty0,y1,y2&gt&gt
# &ltx0,x1,y0,y1,y2&gt
</code></pre><p><code>apl n</code> takes a pair of singleton, n-length vector and flattens it.
<code>apr n</code> is the same, but in the opposite order.</p><pre lang=""><code>apl 3 &ltx,&lty0,y1,y2&gt&gt
# &ltx,y0,y1,y2&gt
apr 4 &lt&ltx0,x1,x2,x3&gt,y&gt 
# &ltx0,x1,x2,x3,y&gt
</code></pre><p><code>zip n</code> is a regular zip function. <code>tran n m</code> extends this to a vector
transpose. <code>zip n</code> is equivalent to <code>tran 2 n</code>. <code>zip</code> takes 2 n-length
vectors.</p><h2>Higher-order Functions</h2><p>You can pass arguments to your functions. Here's an example</p><pre lang=""><code>fst R = [R, id].
</code></pre><p><code>R</code> is a block, so is <code>id</code>. Thus <code>fst R</code> is a 2-input, 2-output block.
A flipped version, <code>snd</code> also exists. We could therefore define <code>add3</code>
like so:</p><pre lang=""><code>add3 = fst add ; add.
</code></pre><p>We could do <code>map</code> too. But we need to specify the input vector size.
We'll learn how to write it ourselves later.</p><pre lang=""><code>squared n = map n (fork ; mult).
current = squared 3.
</code></pre><pre lang="sh"><code>$ re &quot1 2 3&quot
    0 - &lt1,2,3&gt ~ &lt1,4,9&gt
</code></pre><h2>Converse</h2><p>The converse of a component is defined in the prelude. We write the 
converse of <code>R</code> as <code>R^~1</code>. </p><p><img alt="A diagramatic representation of the converse function" src="image-7.png"></p><pre lang=""><code>R^~1 = x $wire &lta, a, x&gt ; [id, R, id] ; &ltb, y, y&gt $wire b.
</code></pre><p><code>pi1</code> and <code>pi2</code> are common selection operators.</p><pre lang=""><code>pi1 = &lta, b&gt $wire a.
pi2 = &lta, b&gt $wire b.
</code></pre><p>They are also frequently inverted. </p><h3>Conjugate</h3><p>A converse is not an inverse. It is just swapping the direction of the
wires. This might mean that <code>R^~1</code> is an inverse function (as in the 
case of <code>id</code>, or <code>fork</code>).</p><p><code>Q^~1 ; R ; Q</code> is a common enough pattern that we shorthand it with 
<code>R \ Q</code>. This is called the conjugate. You might want to do this to 
map between types and back again. </p><p><code>P \ (Q ; R)</code> is <code>(P \ Q) \ R</code>.</p><p>We can also now understand the definition of <code>map</code>.</p><pre lang=""><code>map n R = IF (n $eq 0) THEN [] ELSE ( [R, map (n-1) R] \ (apl (n-1)) ).
</code></pre><p>Everything up to <code>apl</code> should make sense. Without <code>apl</code>, this produces
a box with two inputs <code>[R1, [R2, [R3, [...]]]]</code>. Recall that  <code>apl n</code> 
looks like this</p><pre lang=""><code>&lta,&ltx1,..,xn&gt&gt (apl n) &lta,x1,..,xn&gt
</code></pre><p>So this nested map conjugated by <code>apl</code> will first translate the flat 
vector input into a nested from, and then undo that translation.</p><h2>Constants </h2><p>Ruby has constant values. For example, if we wish to ignore the input
to a block and output a constant instead.</p><pre lang=""><code>fourtytwo = VAR x . x $rel 42.
</code></pre><p>A constant is also a component that has a an output on the range and the
domain.</p><p><img alt="A block with '42' inside has an outgoing arrow on both its left and
right sides." src="image-6.png"></p><p>This component can be described as a function of a constant with the
tools we have discussed. But a component with a single output and no
input does not make sense in Ruby.</p><pre lang=""><code>splitIgnore x = VAR a . &lta, x&gt $rel x.
const x = pi2^~1 ; splitIgnore x.
</code></pre><p>Diagrams just show what circuit things represent. In this case, the 
diagram is not a circuit you would ever build.</p><p><img alt="A diagramatic representation of const 42, with internal 
components" src="image-8.png"></p><h2>Types</h2><p>Ruby has <code>uint</code>s, <code>int</code> and <code>sreal</code>s. It also has tuples like 
<code>&ltint, uint, &ltint, sreal&gt&gt</code> or <code>&ltint, int, int&gt</code> which is just <code>&ltint&gt₃</code>.
It also has bits.</p><p>Ruby is typechecked at runtime and compile time in the Rebecca 
simulator.</p><h2>Grid Components</h2><p>It can be useful to arrange components in a grid, like this:</p><p>DIAGRAM</p><p>For these kind of arrangements, all blocks have two inputs and two
outputs, so they look like <code>&lta, b&gt R &ltc, d&gt</code>.</p><p>we have new combinators. <code>&lt-&gt</code> (beside) connects things next to each
other. Thus we have a type like <code>&lta, &ltb, c&gt&gt (Q &lt-&gt R) &lt&ltp, q&gt, r&gt</code>.</p><p>DIAGRAM</p><p><code>&lt|&gt</code> is 'below'. <code>(Q^~1 &lt-&gt R^~1)^~1</code> is equivalent to <code>Q &lt|&gt R</code>. 
If you work through that equivalence you will see that it means 'place
<code>Q</code> below <code>R</code>'. <code>row n</code> and <code>col n</code> are the repeated versions of these 
combinators.</p><p>It is common to convert a chain component into a grid component. We
can do this with <code>pi1 ; R ; pi2~1</code>. This looks like this:</p><p>DIAGRAM</p><p>The transposed conjugate <code>\\</code> is a special conjugate operator for grid
components. It is <code>R \\ [P, Q]</code>.</p><pre lang=""><code>R \\ [S, T] = [T^~1, S^~1] ; R ; [S, T]
</code></pre><p>Essentially this has the conjugate flowing down on <code>S</code> and left-to-right
on <code>T</code>.</p><h3>Reduce</h3><p><code>rdr n</code> is "reduce-right". Here is the definition. It is hard to 
understand right away, so just keep reading and I'll get back to it
later.</p><pre lang=""><code>rdr n R = col n (R ; pi1^~1) ; pi1.
</code></pre><p>It is useful to recall what this operation means in a functional 
language. A reduce (or fold) describes some code where we update <code>y</code>
based on a sequence of input data <code>xs</code>.</p><pre lang="py"><code>y = ...
for x in xs:
    y = f(x)
</code></pre><p><img alt="TODO" src="image-9.png"></p><p>You might remember that there are left-folds and right-folds and be 
wondering if the "right" in "reduce-right" has anything to do with 
that. If you're not, you can skip this bit. If you are, recall that:</p><pre lang="hs"><code>foldr f y [x₁,x₂,x₃] = (f x₁ (f x₂ (f x₃ y)))
foldl f y [x₁,x₂,x₃] = (f (f (f y x₁) x₂) x₃)
</code></pre><p>If you're clever, you might notice that _basically_ <code>foldr</code> is just
<code>foldl</code> with the <code>xs</code> reversed. If you're really clever, you'll notice
that in a lazy language, <code>foldr</code> can short circuit early and <code>foldl</code>
can't. E.g. <code>foldr (||) False (True : repeat False)</code> actually evaluates,
whereas the <code>foldl</code> version never terminates.</p><p>Anyway, this doesn't really matter for our purposes. The "right" in
"reduce-right" is about how the right hand side of this column has
no wires coming out of it.</p><p>Let's return to the definition of <code>rdr</code>. It's supposed to make something
that looks like the diagram we made for a fold. It's useful to also 
wonder a bit about how the definition expands, so that we can better
understand some of the tricks used in making complex combinators.</p><p><code>R ; pi1^~1</code> turns a component <code>&lta, b&gt R b</code> into a grid component. We'll
call this <code>R&apos</code>. Then, we arrange these components in a column. Note that
this column arrangement still has type
<code>&ltX, Y&gt (col n (R ; pi1^~1)) &ltY, Z&gt</code>. The <code>X</code> and <code>Z</code> here are tuples of
size <code>n</code>. This component is the one with the dark grey background on
the right circuit in the diagram below. </p><p>All the wires on the right are useless, so we ignore them with <code>pi1</code>. </p><p><img alt="TODO" src="image-10.png"></p><h2>Registers </h2><p><!-- 
btree 1 R = R 
btree (n+1) R = half m ; [btree n R, btree n R] ; R, m = 2^n</p><p> -->
’
</p>
            </div>
        </div>
    </div>
</body>

</html>